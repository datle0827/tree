<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>D√°ng Xinh</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(to bottom, #0a1128, #1a2456);
            overflow: hidden;
            height: 100vh;
        }

        #container {
            width: 100%;
            height: 100vh;
            position: relative;
        }

        #upload-section {
            display: none;
        }

        #upload-section h3 {
            margin-bottom: 10px;
            color: #1a472a;
            font-size: 18px;
        }

        #file-input {
            margin-bottom: 10px;
        }

        .controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 15px 30px;
            border-radius: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            z-index: 1000;
        }

        .controls p {
            color: #1a472a;
            font-size: 14px;
            text-align: center;
        }

        .zoom-hint {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.9);
            padding: 10px 20px;
            border-radius: 15px;
            color: #1a472a;
            font-size: 12px;
            z-index: 3000;
            display: none;
            animation: fadeInOut 3s;
        }

        .zoom-hint.show {
            display: block;
        }

        @keyframes fadeInOut {
            0%, 100% { opacity: 0; }
            10%, 90% { opacity: 1; }
        }

        #modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }

        #modal.active {
            display: flex;
        }

        #modal img {
            max-width: 90%;
            max-height: 90%;
            border-radius: 10px;
            box-shadow: 0 0 50px rgba(255, 215, 0, 0.8);
            cursor: move;
            transition: transform 0.1s;
            position: relative;
        }

        #modal.zoomed img {
            max-width: none;
            max-height: none;
            width: auto;
            height: auto;
        }

        #modal-close {
            position: absolute;
            top: 30px;
            right: 30px;
            color: white;
            font-size: 40px;
            cursor: pointer;
            background: rgba(0, 0, 0, 0.5);
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.3s;
            z-index: 10;
        }

        #modal-close:hover {
            transform: scale(1.1);
        }

        .modal-lights {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
            top: 0;
            left: 0;
        }

        .modal-light {
            position: absolute;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            animation: twinkle 1s infinite alternate;
        }

        @keyframes twinkle {
            0% {
                opacity: 0.3;
                transform: scale(0.8);
            }
            100% {
                opacity: 1;
                transform: scale(1.2);
            }
        }

        #merry-christmas {
            position: absolute;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 48px;
            font-weight: bold;
            color: #fff;
            z-index: 1;
            font-family: 'Arial Black', sans-serif;
            letter-spacing: 5px;
            animation: sparkleText 3.5s infinite;
            pointer-events: none;
            white-space: nowrap;
            width: 100%;
            text-align: center;
        }

        @media (max-width: 768px) {
            #merry-christmas {
                font-size: 24px;
                top: 20px;
                letter-spacing: 2px;
            }

            .controls {
                bottom: 10px;
                padding: 10px 15px;
            }

            .controls p {
                font-size: 11px;
            }

            .zoom-hint {
                font-size: 11px;
                bottom: 60px;
                padding: 8px 15px;
            }

            #modal-close {
                top: 15px;
                right: 15px;
                font-size: 30px;
                width: 40px;
                height: 40px;
            }
        }

        @keyframes sparkleText {
            0% {
                color: #ff0000;
                text-shadow: 0 0 20px #ff0000, 0 0 40px #ff0000;
                transform: translateX(-50%) scale(1);
            }
            14% {
                color: #ff7f00;
                text-shadow: 0 0 20px #ff7f00, 0 0 40px #ff7f00;
                transform: translateX(-50%) scale(1.05);
            }
            28% {
                color: #ffff00;
                text-shadow: 0 0 20px #ffff00, 0 0 40px #ffff00;
                transform: translateX(-50%) scale(1);
            }
            42% {
                color: #00ff00;
                text-shadow: 0 0 20px #00ff00, 0 0 40px #00ff00;
                transform: translateX(-50%) scale(1.05);
            }
            57% {
                color: #0000ff;
                text-shadow: 0 0 20px #0000ff, 0 0 40px #0000ff;
                transform: translateX(-50%) scale(1);
            }
            71% {
                color: #4b0082;
                text-shadow: 0 0 20px #4b0082, 0 0 40px #4b0082;
                transform: translateX(-50%) scale(1.05);
            }
            85% {
                color: #9400d3;
                text-shadow: 0 0 20px #9400d3, 0 0 40px #9400d3;
                transform: translateX(-50%) scale(1);
            }
            100% {
                color: #ff0000;
                text-shadow: 0 0 20px #ff0000, 0 0 40px #ff0000;
                transform: translateX(-50%) scale(1.05);
            }
        }
    </style>
</head>

<body>
    <div id="merry-christmas">üéÑ MERRY CHRISTMAS 2025 üéÑ</div>

    <div id="upload-section">
        <h3>üéÖ Th√™m ·∫£nh l√™n c√¢y</h3>
        <input type="file" id="file-input" accept="image/*" multiple>
        <p style="font-size: 12px; color: #666; margin-top: 5px;">Ch·ªçn nhi·ªÅu ·∫£nh c√πng l√∫c</p>
    </div>

    <div class="controls">
        <p class="desktop-hint">üñ±Ô∏è K√©o chu·ªôt ƒë·ªÉ xoay ‚Ä¢ LƒÉn chu·ªôt ƒë·ªÉ thu ph√≥ng ‚Ä¢ Click ·∫£nh ƒë·ªÉ ph√≥ng to</p>
        <p class="mobile-hint" style="display: none;">üëÜ Vu·ªët ƒë·ªÉ xoay ‚Ä¢ 2 ng√≥n ƒë·ªÉ zoom ‚Ä¢ Ch·∫°m ·∫£nh ƒë·ªÉ ph√≥ng to</p>
    </div>

    <div id="modal">
        <div class="modal-lights"></div>
        <div id="modal-close">&times;</div>
        <img id="modal-img" src="" alt="·∫¢nh ph√≥ng to">
    </div>

    <div class="zoom-hint" id="zoom-hint">
        <span class="desktop-hint">üí° LƒÉn chu·ªôt ƒë·ªÉ zoom ‚Ä¢ K√©o ƒë·ªÉ di chuy·ªÉn ·∫£nh</span>
        <span class="mobile-hint" style="display: none;">üí° 2 ng√≥n ƒë·ªÉ zoom ‚Ä¢ Vu·ªët ƒë·ªÉ di chuy·ªÉn ·∫£nh</span>
    </div>

    <div id="container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, tree, photoFrames = [];
        let userImages = [];
        let lights = [];

        function init() {
            // Ph√°t hi·ªán thi·∫øt b·ªã mobile
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            
            if (isMobile) {
                document.querySelectorAll('.desktop-hint').forEach(el => el.style.display = 'none');
                document.querySelectorAll('.mobile-hint').forEach(el => el.style.display = 'inline');
            }

            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x0a1128, 15, 60);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 6, 12);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x0a1128, 1);
            renderer.shadowMap.enabled = true;
            document.getElementById('container').appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);

            const topLight = new THREE.PointLight(0xffd700, 1.5, 50);
            topLight.position.set(0, 12, 0);
            scene.add(topLight);

            const frontLight = new THREE.DirectionalLight(0xffffff, 0.8);
            frontLight.position.set(5, 10, 15);
            scene.add(frontLight);

            createChristmasTree();
            addSnowflakes();
            addStars();
            loadPresetImages();

            window.addEventListener('resize', onWindowResize);
            setupControls();
            document.getElementById('modal-close').addEventListener('click', closeModal);
            document.getElementById('modal').addEventListener('click', function (e) {
                if (e.target.id === 'modal') closeModal();
            });

            animate();
        }

        function createChristmasTree() {
            tree = new THREE.Group();

            const trunkGeometry = new THREE.CylinderGeometry(0.4, 0.6, 4.5, 12);
            const trunkMaterial = new THREE.MeshPhongMaterial({
                color: 0x6b4423,
                shininess: 10
            });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 2.25;
            tree.add(trunk);

            const layers = [
                { radius: 3.5, height: 3.5, y: 5.5, branches: 5 },
                { radius: 3, height: 3, y: 7.8, branches: 4 },
                { radius: 2.5, height: 2.5, y: 9.5, branches: 4 },
                { radius: 2, height: 2, y: 11, branches: 3 },
                { radius: 1.5, height: 1.5, y: 12.2, branches: 3 }
            ];

            addGiftBoxes();

            layers.forEach((layer, layerIndex) => {
                for (let b = 0; b < layer.branches; b++) {
                    const branchY = layer.y - layer.height / 2 + (b / (layer.branches - 1)) * layer.height;
                    const branchRadius = layer.radius * (1 - b / layer.branches * 0.3);

                    const geometry = new THREE.ConeGeometry(branchRadius, layer.height / layer.branches * 1.3, 16);
                    const material = new THREE.MeshPhongMaterial({
                        color: layerIndex % 2 === 0 ? 0x0d5c1f : 0x0a4a18,
                        shininess: 30,
                        flatShading: false
                    });
                    const cone = new THREE.Mesh(geometry, material);
                    cone.position.y = branchY;
                    tree.add(cone);

                    const leafCount = Math.floor(branchRadius * 12);
                    for (let i = 0; i < leafCount; i++) {
                        const angle = (i / leafCount) * Math.PI * 2;
                        const leafRadius = branchRadius * (0.85 + Math.random() * 0.15);

                        const leafGeometry = new THREE.ConeGeometry(0.15, 0.3, 4);
                        const leafMaterial = new THREE.MeshPhongMaterial({
                            color: 0x0d5c1f,
                            shininess: 20
                        });
                        const leaf = new THREE.Mesh(leafGeometry, leafMaterial);

                        leaf.position.set(
                            Math.cos(angle) * leafRadius,
                            branchY + Math.random() * 0.2,
                            Math.sin(angle) * leafRadius
                        );

                        leaf.rotation.z = Math.PI / 2;
                        leaf.rotation.y = angle;

                        tree.add(leaf);
                    }
                }
            });

            const ornamentPositions = [];
            for (let i = 0; i < 50; i++) {
                const angle = Math.random() * Math.PI * 2;
                const layerIndex = Math.floor(Math.random() * layers.length);
                const layer = layers[layerIndex];
                const radiusScale = 0.3 + Math.random() * 0.6;
                const radius = layer.radius * radiusScale;
                const height = layer.y + (Math.random() - 0.5) * layer.height * 0.6;

                const ornamentGeometry = new THREE.SphereGeometry(0.12 + Math.random() * 0.08, 12, 12);
                const colors = [0xff0000, 0xffd700, 0x0000ff, 0xff1493, 0xff6347, 0x00ff00];
                const color = colors[Math.floor(Math.random() * colors.length)];
                const ornamentMaterial = new THREE.MeshPhongMaterial({
                    color: color,
                    emissive: color,
                    emissiveIntensity: 0.4,
                    shininess: 100
                });
                const ornament = new THREE.Mesh(ornamentGeometry, ornamentMaterial);

                ornament.position.set(
                    Math.cos(angle) * radius,
                    height,
                    Math.sin(angle) * radius
                );
                tree.add(ornament);

                if (i % 3 === 0) {
                    const light = new THREE.PointLight(color, 0.5, 3);
                    light.position.copy(ornament.position);
                    tree.add(light);
                    lights.push({ light: light, speed: 0.5 + Math.random() * 1.5 });
                }
            }

            const spiralLights = 100;
            for (let i = 0; i < spiralLights; i++) {
                const t = i / spiralLights;
                const angle = t * Math.PI * 10;
                const height = 5 + t * 8;
                const radius = 3.5 * (1 - t * 0.8);

                const lightGeometry = new THREE.SphereGeometry(0.08, 8, 8);
                const lightColors = [0xffff00, 0xff0000, 0x00ff00, 0x0000ff, 0xff00ff];
                const lightColor = lightColors[i % lightColors.length];
                const lightMaterial = new THREE.MeshBasicMaterial({
                    color: lightColor,
                    emissive: lightColor,
                    emissiveIntensity: 1
                });
                const lightBulb = new THREE.Mesh(lightGeometry, lightMaterial);

                lightBulb.position.set(
                    Math.cos(angle) * radius,
                    height,
                    Math.sin(angle) * radius
                );
                tree.add(lightBulb);
            }

            const starGroup = new THREE.Group();

            const starGeometry = createStarGeometry(0.5, 0.25, 5);
            const starMaterial = new THREE.MeshPhongMaterial({
                color: 0xffd700,
                emissive: 0xffd700,
                emissiveIntensity: 1,
                shininess: 100
            });
            const star = new THREE.Mesh(starGeometry, starMaterial);
            starGroup.add(star);

            const star2 = star.clone();
            star2.rotation.z = Math.PI / 10;
            starGroup.add(star2);

            const starLight = new THREE.PointLight(0xffd700, 2, 15);
            starGroup.add(starLight);

            starGroup.position.y = 13.5;
            tree.add(starGroup);

            tree.userData.star = starGroup;

            scene.add(tree);
        }

        function createStarGeometry(outerRadius, innerRadius, points) {
            const shape = new THREE.Shape();
            for (let i = 0; i < points * 2; i++) {
                const radius = i % 2 === 0 ? outerRadius : innerRadius;
                const angle = (i / (points * 2)) * Math.PI * 2;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                if (i === 0) shape.moveTo(x, y);
                else shape.lineTo(x, y);
            }
            shape.closePath();

            const geometry = new THREE.ExtrudeGeometry(shape, {
                depth: 0.1,
                bevelEnabled: true,
                bevelThickness: 0.05,
                bevelSize: 0.05,
                bevelSegments: 3
            });
            return geometry;
        }

        function addSnowflakes() {
            const snowflakeGeometry = new THREE.BufferGeometry();
            const snowflakeCount = 500;
            const positions = new Float32Array(snowflakeCount * 3);

            for (let i = 0; i < snowflakeCount * 3; i += 3) {
                positions[i] = Math.random() * 60 - 30;
                positions[i + 1] = Math.random() * 30;
                positions[i + 2] = Math.random() * 60 - 30;
            }

            snowflakeGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

            const circleTexture = createCircleTexture();

            const snowflakeMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.3,
                map: circleTexture,
                transparent: true,
                opacity: 0.8,
                alphaTest: 0.5
            });
            const snowflakes = new THREE.Points(snowflakeGeometry, snowflakeMaterial);
            scene.add(snowflakes);

            scene.userData.snowflakes = snowflakes;
        }

        function createCircleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const context = canvas.getContext('2d');
            context.beginPath();
            context.arc(16, 16, 16, 0, 2 * Math.PI);
            context.fillStyle = '#ffffff';
            context.fill();
            return new THREE.CanvasTexture(canvas);
        }

        function addGiftBoxes() {
            const boxColors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff];
            const boxCount = 30;

            for (let i = 0; i < boxCount; i++) {
                const size = 0.6 + Math.random() * 0.6;
                const boxGeometry = new THREE.BoxGeometry(size, size, size);
                const color = boxColors[Math.floor(Math.random() * boxColors.length)];

                const boxMaterial = new THREE.MeshPhongMaterial({
                    color: color,
                    shininess: 50
                });

                const box = new THREE.Mesh(boxGeometry, boxMaterial);

                const angle = (i / boxCount) * Math.PI * 2 + (Math.random() * 0.5);
                const radius = 0.5 + Math.random() * 1.5;

                box.position.set(
                    Math.cos(angle) * radius,
                    size / 2,
                    Math.sin(angle) * radius
                );

                box.rotation.y = Math.random() * Math.PI;
                tree.add(box);

                const ribbonGeo = new THREE.BoxGeometry(size * 1.02, size * 1.02, size * 0.2);
                const ribbonMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                const ribbon = new THREE.Mesh(ribbonGeo, ribbonMat);
                box.add(ribbon);

                const ribbonGeo2 = new THREE.BoxGeometry(size * 0.2, size * 1.02, size * 1.02);
                const ribbon2 = new THREE.Mesh(ribbonGeo2, ribbonMat);
                box.add(ribbon2);
            }
        }

        function addStars() {
            const starGeometry = new THREE.BufferGeometry();
            const starCount = 300;
            const positions = new Float32Array(starCount * 3);

            for (let i = 0; i < starCount * 3; i += 3) {
                positions[i] = Math.random() * 100 - 50;
                positions[i + 1] = Math.random() * 50 + 10;
                positions[i + 2] = Math.random() * 100 - 50;
            }

            starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const starMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.2,
                transparent: true
            });
            const stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);
        }

        function loadPresetImages() {
            const presetImages = [
                'https://i.postimg.cc/zvnDn1yM/photo1.jpg',
                'https://i.postimg.cc/gJhGWPH7/photo2.jpg',
                'https://i.postimg.cc/26WCDf73/photo3.jpg',
                'https://i.postimg.cc/MGNzNGVB/photo4.jpg',
                'https://i.postimg.cc/8khTXN5C/photo5.jpg',
                'https://i.postimg.cc/1XZsRYvd/photo6.jpg',
                'https://i.postimg.cc/nLpdZ8fH/358157324-816130869733116-6625354429678918591-n.jpg',
                'https://i.postimg.cc/zBf0bnfS/z7364682153289-48a32f90c5da601be0d9ca3f883c6005.jpg',
                'https://i.postimg.cc/cHJXgQJf/z7364682176078-2ccb5d78727b72f7520edfbeae3a9f96.jpg',
                'https://i.postimg.cc/gcxr4nXs/Screenshot-(248).png'
            ];

            console.log('ƒêang t·∫£i 6 ·∫£nh gia ƒë√¨nh...', presetImages);

            presetImages.forEach(imagePath => {
                addPhotoFrame(imagePath);
            });
        }

        function addPhotoFrame(imageUrl) {
            console.log('B·∫Øt ƒë·∫ßu t·∫£i ·∫£nh:', imageUrl);
            const loader = new THREE.TextureLoader();

            loader.load(
                imageUrl,
                function (texture) {
                    console.log('‚úì T·∫£i ·∫£nh th√†nh c√¥ng:', imageUrl);
                    const frameGroup = new THREE.Group();

                    const frameGeometry = new THREE.PlaneGeometry(1.6, 1.6);
                    const frameMaterial = new THREE.MeshPhongMaterial({
                        color: 0xffd700,
                        emissive: 0xffd700,
                        emissiveIntensity: 0.5,
                        shininess: 100,
                        side: THREE.DoubleSide
                    });
                    const frameBorder = new THREE.Mesh(frameGeometry, frameMaterial);
                    frameGroup.add(frameBorder);

                    const innerFrameGeometry = new THREE.PlaneGeometry(1.5, 1.5);
                    const innerFrameMaterial = new THREE.MeshPhongMaterial({
                        color: 0xffffff,
                        side: THREE.DoubleSide
                    });
                    const innerFrame = new THREE.Mesh(innerFrameGeometry, innerFrameMaterial);
                    innerFrame.position.z = 0.01;
                    frameGroup.add(innerFrame);

                    const photoGeometry = new THREE.PlaneGeometry(1.3, 1.3);
                    const photoMaterial = new THREE.MeshBasicMaterial({
                        map: texture,
                        side: THREE.DoubleSide
                    });
                    const photo = new THREE.Mesh(photoGeometry, photoMaterial);
                    photo.position.z = 0.02;
                    frameGroup.add(photo);

                    const numPhotos = photoFrames.length;
                    // Ph√¢n b·ªë ƒë·ªÅu theo v√≤ng tr√≤n, m·ªói ·∫£nh c√°ch nhau 360¬∞/t·ªïng s·ªë ·∫£nh
                    const totalPhotos = 10; // T·ªïng s·ªë ·∫£nh d·ª± ki·∫øn
                    const angle = (numPhotos / totalPhotos) * Math.PI * 2;
                    const radius = 4.0; // B√°n k√≠nh c·ªë ƒë·ªãnh ƒë·ªÉ kh√¥ng b·ªã ƒë√®
                    // Chi·ªÅu cao th·∫•p h∆°n: t·ª´ 4.5 ƒë·∫øn 8.5 (thay v√¨ 5.5 ƒë·∫øn 10.5)
                    const height = 4.5 + (numPhotos % 5) * 1.0; // Ph√¢n t·∫ßng 5 t·∫ßng, m·ªói t·∫ßng c√°ch 1.0 ƒë∆°n v·ªã

                    frameGroup.position.set(
                        Math.cos(angle) * radius,
                        height,
                        Math.sin(angle) * radius
                    );

                    frameGroup.lookAt(
                        Math.cos(angle) * radius * 2,
                        height,
                        Math.sin(angle) * radius * 2
                    );

                    frameGroup.userData.imageUrl = imageUrl;

                    const frameLight = new THREE.PointLight(0xffd700, 0.5, 3);
                    frameLight.position.set(0, 0, 0.3);
                    frameGroup.add(frameLight);
                    lights.push({ light: frameLight, speed: 1 });

                    tree.add(frameGroup);
                    photoFrames.push(frameGroup);
                    console.log('‚úì ƒê√£ th√™m ·∫£nh v√†o c√¢y, t·ªïng s·ªë ·∫£nh:', photoFrames.length);
                },
                undefined,
                function (error) {
                    console.error('‚úó L·ªói khi t·∫£i ·∫£nh:', imageUrl, error);
                });
        }

        function setupControls() {
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };
            let previousTouchPosition = { x: 0, y: 0 };

            // Mouse controls cho desktop
            renderer.domElement.addEventListener('mousedown', function (e) {
                isDragging = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });

            renderer.domElement.addEventListener('mousemove', function (e) {
                if (isDragging) {
                    const deltaX = e.clientX - previousMousePosition.x;
                    tree.rotation.y += deltaX * 0.01;
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                }
            });

            renderer.domElement.addEventListener('mouseup', function () {
                isDragging = false;
            });

            // Touch controls cho mobile
            renderer.domElement.addEventListener('touchstart', function (e) {
                if (e.touches.length === 1) {
                    isDragging = true;
                    previousTouchPosition = { 
                        x: e.touches[0].clientX, 
                        y: e.touches[0].clientY 
                    };
                }
            }, { passive: true });

            renderer.domElement.addEventListener('touchmove', function (e) {
                if (isDragging && e.touches.length === 1) {
                    const deltaX = e.touches[0].clientX - previousTouchPosition.x;
                    tree.rotation.y += deltaX * 0.01;
                    previousTouchPosition = { 
                        x: e.touches[0].clientX, 
                        y: e.touches[0].clientY 
                    };
                }
            }, { passive: true });

            renderer.domElement.addEventListener('touchend', function () {
                isDragging = false;
            });

            // Pinch to zoom cho mobile
            let initialPinchDistance = 0;
            renderer.domElement.addEventListener('touchstart', function (e) {
                if (e.touches.length === 2) {
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    initialPinchDistance = Math.sqrt(dx * dx + dy * dy);
                }
            }, { passive: true });

            renderer.domElement.addEventListener('touchmove', function (e) {
                if (e.touches.length === 2) {
                    e.preventDefault();
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (initialPinchDistance > 0) {
                        const delta = (distance - initialPinchDistance) * 0.01;
                        camera.position.z -= delta;
                        camera.position.z = Math.max(8, Math.min(25, camera.position.z));
                        initialPinchDistance = distance;
                    }
                }
            }, { passive: false });

            // Wheel zoom cho desktop
            renderer.domElement.addEventListener('wheel', function (e) {
                e.preventDefault();
                camera.position.z += e.deltaY * 0.01;
                camera.position.z = Math.max(8, Math.min(25, camera.position.z));
            });

            // Click/Tap ƒë·ªÉ m·ªü ·∫£nh
            renderer.domElement.addEventListener('click', handleImageClick);
            renderer.domElement.addEventListener('touchend', handleImageClick);

            function handleImageClick(e) {
                if (isDragging) return;

                let clientX, clientY;
                if (e.type === 'click') {
                    clientX = e.clientX;
                    clientY = e.clientY;
                } else if (e.type === 'touchend' && e.changedTouches) {
                    clientX = e.changedTouches[0].clientX;
                    clientY = e.changedTouches[0].clientY;
                } else {
                    return;
                }

                const mouse = new THREE.Vector2();
                mouse.x = (clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(clientY / window.innerHeight) * 2 + 1;

                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(mouse, camera);

                const intersects = raycaster.intersectObjects(tree.children, true);

                for (let intersect of intersects) {
                    let obj = intersect.object;
                    while (obj.parent && !obj.userData.imageUrl) {
                        obj = obj.parent;
                    }

                    if (obj.userData.imageUrl) {
                        openModal(obj.userData.imageUrl);
                        break;
                    }
                }
            }
        }

        function openModal(imageUrl) {
            document.getElementById('modal-img').src = imageUrl;
            document.getElementById('modal').classList.add('active');
            createModalLights();
            setupModalControls();
            
            // Hi·ªÉn th·ªã hint
            const hint = document.getElementById('zoom-hint');
            hint.classList.add('show');
            setTimeout(() => {
                hint.classList.remove('show');
            }, 3000);
        }

        let modalZoom = 1;
        let modalPanX = 0;
        let modalPanY = 0;
        let isDraggingModal = false;
        let modalStartX = 0;
        let modalStartY = 0;

        function setupModalControls() {
            const modalImg = document.getElementById('modal-img');
            const modal = document.getElementById('modal');
            
            // Reset khi m·ªü modal
            modalZoom = 1;
            modalPanX = 0;
            modalPanY = 0;
            updateModalTransform();

            // Zoom b·∫±ng scroll chu·ªôt (desktop)
            modalImg.addEventListener('wheel', handleModalWheel);
            
            // K√©o ·∫£nh (desktop)
            modalImg.addEventListener('mousedown', handleModalMouseDown);
            document.addEventListener('mousemove', handleModalMouseMove);
            document.addEventListener('mouseup', handleModalMouseUp);

            // H·ªó tr·ª£ touch cho mobile - single touch ƒë·ªÉ k√©o
            modalImg.addEventListener('touchstart', handleModalTouchStart);
            document.addEventListener('touchmove', handleModalTouchMove);
            document.addEventListener('touchend', handleModalTouchEnd);

            // Pinch to zoom cho mobile
            let initialModalPinchDistance = 0;
            modalImg.addEventListener('touchstart', function(e) {
                if (e.touches.length === 2) {
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    initialModalPinchDistance = Math.sqrt(dx * dx + dy * dy);
                }
            }, { passive: true });

            modalImg.addEventListener('touchmove', function(e) {
                if (e.touches.length === 2) {
                    e.preventDefault();
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (initialModalPinchDistance > 0) {
                        const scale = distance / initialModalPinchDistance;
                        modalZoom *= scale;
                        modalZoom = Math.max(0.5, Math.min(5, modalZoom));
                        initialModalPinchDistance = distance;
                        updateModalTransform();
                    }
                }
            }, { passive: false });
        }

        function handleModalWheel(e) {
            e.preventDefault();
            e.stopPropagation();
            
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            modalZoom *= delta;
            modalZoom = Math.max(0.5, Math.min(5, modalZoom)); // Gi·ªõi h·∫°n zoom t·ª´ 0.5x ƒë·∫øn 5x
            
            updateModalTransform();
        }

        function handleModalMouseDown(e) {
            if (e.target.id === 'modal-img') {
                isDraggingModal = true;
                modalStartX = e.clientX - modalPanX;
                modalStartY = e.clientY - modalPanY;
                e.preventDefault();
            }
        }

        function handleModalMouseMove(e) {
            if (isDraggingModal) {
                modalPanX = e.clientX - modalStartX;
                modalPanY = e.clientY - modalStartY;
                updateModalTransform();
            }
        }

        function handleModalMouseUp() {
            isDraggingModal = false;
        }

        let modalTouchStartX = 0;
        let modalTouchStartY = 0;

        function handleModalTouchStart(e) {
            if (e.touches.length === 1) {
                isDraggingModal = true;
                modalTouchStartX = e.touches[0].clientX - modalPanX;
                modalTouchStartY = e.touches[0].clientY - modalPanY;
                e.preventDefault();
            }
        }

        function handleModalTouchMove(e) {
            if (isDraggingModal && e.touches.length === 1) {
                modalPanX = e.touches[0].clientX - modalTouchStartX;
                modalPanY = e.touches[0].clientY - modalTouchStartY;
                updateModalTransform();
                e.preventDefault();
            }
        }

        function handleModalTouchEnd() {
            isDraggingModal = false;
        }

        function updateModalTransform() {
            const modalImg = document.getElementById('modal-img');
            modalImg.style.transform = `translate(${modalPanX}px, ${modalPanY}px) scale(${modalZoom})`;
        }

        function createModalLights() {
            const modalLightsContainer = document.querySelector('.modal-lights');
            modalLightsContainer.innerHTML = '';
            
            const colors = ['#ff0000', '#ffff00', '#00ff00', '#0000ff', '#ff00ff', '#ffd700', '#ff6347'];
            const lightCount = 50;
            
            for (let i = 0; i < lightCount; i++) {
                const light = document.createElement('div');
                light.className = 'modal-light';
                
                const side = Math.floor(Math.random() * 4);
                let x, y;
                
                if (side === 0) {
                    x = Math.random() * 100;
                    y = Math.random() * 10;
                } else if (side === 1) {
                    x = 90 + Math.random() * 10;
                    y = Math.random() * 100;
                } else if (side === 2) {
                    x = Math.random() * 100;
                    y = 90 + Math.random() * 10;
                } else {
                    x = Math.random() * 10;
                    y = Math.random() * 100;
                }
                
                light.style.left = x + '%';
                light.style.top = y + '%';
                light.style.backgroundColor = colors[i % colors.length];
                light.style.boxShadow = `0 0 15px ${colors[i % colors.length]}`;
                light.style.animationDelay = (Math.random() * 1) + 's';
                
                modalLightsContainer.appendChild(light);
            }
        }

        function closeModal() {
            const modal = document.getElementById('modal');
            const modalImg = document.getElementById('modal-img');
            
            modal.classList.remove('active');
            document.querySelector('.modal-lights').innerHTML = '';
            
            // X√≥a event listeners
            modalImg.removeEventListener('wheel', handleModalWheel);
            modalImg.removeEventListener('mousedown', handleModalMouseDown);
            modalImg.removeEventListener('touchstart', handleModalTouchStart);
            
            // Reset transform
            modalZoom = 1;
            modalPanX = 0;
            modalPanY = 0;
            modalImg.style.transform = '';
        }

        let time = 0;
        function animate() {
            requestAnimationFrame(animate);
            time += 0.016;

            tree.rotation.y += 0.002;

            if (tree.userData.star) {
                tree.userData.star.rotation.z += 0.01;
                tree.userData.star.position.y = 13.5 + Math.sin(time * 2) * 0.1;
            }

            lights.forEach(lightObj => {
                const intensity = Math.sin(time * lightObj.speed) * 0.3 + 0.7;
                lightObj.light.intensity = intensity;
            });

            if (scene.userData.snowflakes) {
                const positions = scene.userData.snowflakes.geometry.attributes.position.array;
                for (let i = 1; i < positions.length; i += 3) {
                    positions[i] -= 0.02;
                    if (positions[i] < 0) {
                        positions[i] = 30;
                    }
                }
                scene.userData.snowflakes.geometry.attributes.position.needsUpdate = true;
            }

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        init();
    </script>
</body>

</html>